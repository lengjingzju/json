# yyjson ≠ 万能王者：它只是 LJSON DOM 复用模式的一个特化版本

*——一场关于 JSON 引擎架构哲学的深度对话*

## 引言：性能之外，还有架构的边界

在 C 语言 JSON 库的世界里，yyjson 凭借惊人的解析速度成为众多 benchmark 的常客。但如果你是一位系统级工程师，追求的不只是跑分，而是架构的可控性、可维护性和真实场景下的适应力，那么你会发现：

> **yyjson 本质上只是 LJSON 所提供的 DOM 复用模式的一个特化版本。** (首次提交时间，yyjson 为 **2020.10**，LJSON 为 **2019.10** )

这不是贬低，而是一次架构哲学的澄清。本文将从模式设计、性能策略、内存行为、流式能力等多个维度，深入剖析 yyjson 与 LJSON 的本质差异。

## 一、DOM 复用模式：性能的起点，不是终点

所谓 DOM 复用模式，是指解析 JSON 时复用输入缓冲区中的字符串，避免额外拷贝与堆分配，从而提升性能、降低内存占用。

LJSON 的 DOM 复用模式具备：

- 原地字符串复用（零拷贝）
- 内存池分配结构体（避免频繁 malloc/free）
- 可编辑性（支持修改 key/value）

yyjson 的核心模式与此高度重合，但它进一步做了激进的只读优化。

## 二、yyjson 的极限优化：只读复用场景的王者

yyjson 在 DOM 复用基础上，采取了以下策略以追求极致性能：

- **非标准字符串尾部**：使用 `\0\0\0\0` 替代标准 C 字符串尾部，减少边界判断。
- **宏展开循环**：大量使用宏手动展开解析循环，压榨 CPU 指令流水。
- **预分配冗余内存**：一次性分配大块内存（冗余度较高）存储对象结构，避免频繁 `realloc` 。
- **只读不可编辑**：解析后的结构不可修改（对象结构可以更小，16字节可对齐到cache刷新线），牺牲灵活性换取速度（可编辑需要再次转换）。

这些手段确实让 yyjson 在只读场景下表现惊艳，但也限制了它的适用边界。

> 注：yyjson 仅仅是只读复用原始字符串模式比 LJSON 快；只读模式和 LJSON 互有胜负；可编辑模式可能大幅度落后于 LJSON 。

> 分析1：yyjson 只读模式为什么和 LJSON 互有胜负？yyjson 不支持标准字符串，标准字符串时需要复制一份原始数据（尾后添4个0）再解析；LJSON 支持标准字符串，少了 yyjson 单一模式的激进优化和宏手动展开循环优化。

> 分析2：yyjson 可编辑模式为什么比 LJSON 慢？ yyjson 需要复制转换一份数据到可编辑对象，且内存要翻倍；LJSON 复用模式原始就是可编辑的。

## 三、LJSON 的架构通用性：不仅仅是快

LJSON 提供了多达 **7 种解析模式** 与 **4 种打印模式**，覆盖从内存到文件、从 DOM 到 SAX 的全场景需求：

### 解析模式包括：

1. DOM 经典模式（malloc/free）
2. DOM 内存池模式
3. DOM 复用模式（可编辑，字符串原地复用）
4. DOM 文件流模式（真流式）
5. DOM 文件流内存池模式（真流式 + 内存池）
6. SAX 模式（回调处理）
7. SAX 文件流模式（真流式 + 回调）

> 真流式解析（chunked 文件边读边解析，无需完整读完文件到缓冲再解析）

### 打印模式包括：

1. DOM → 字符串
2. DOM → 文件（真流式）
3. SAX → 字符串
4. SAX → 文件（真流式）

> 真流式打印（边打印边写文件，无需先打印到字符串完后再写文件）

这种架构设计使得 LJSON 能在以下场景中游刃有余：

- **大文件处理**：支持 GB 级 JSON 文件的常数级内存解析
- **嵌入式系统**：低内存占用，无堆分配
- **高频读写**：支持可编辑 DOM 和高性能打印
- **跨平台开发**：纯 C 实现，无第三方依赖

## 四、设计哲学的分野：深度 vs 单点突破

| 维度 | yyjson | LJSON |
|------|--------|--------|
| 核心模式 | DOM 复用（只读） | 多模式（DOM/SAX/流式） |
| 可编辑性 | ❌ 不支持（可转换为可编辑） | ✅ 支持（不用额外转换） |
| 流式处理 | ❌ 不支持（需要完整读取再解析） | ✅ 真流式 |
| 内存策略 | 内存块 + 原地复用 | 内存池 + 原地复用 |
| 代码可读性 | 极低（宏密集）（约2万行代码） | 高（结构清晰）（约1万行代码） |
| 适用场景 | 极限只读解析 | 通用 JSON 处理 |

yyjson 是一把锋利的手术刀，专注于只读解析的极限性能；而 LJSON 是一套完整的工具箱，兼顾性能、灵活性和可维护性。

## 五、结语：选型的本质，是理解架构边界

yyjson 的成功在于它对单一模式的深度打磨，但它的架构本质上只是 LJSON 多模式体系中的一个特化版本（**yyjson ≈ LJSON 的 DOM 复用模式 + 激进只读优化**）。LJSON 的真正价值，在于它能在真实工程环境中，以极低的内存占用和高性能，稳定支撑多样化的 JSON 处理需求。

在选型时，开发者应根据实际场景权衡：是只读解析的极限速度，还是通用处理的架构弹性？理解这两者的本质差异，才能做出真正工程化的决策。

